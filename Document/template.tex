\documentclass[a4paper,openright,12pt]{article}
\usepackage[spanish]{babel} % espanol
\usepackage[utf8]{inputenc}
\usepackage{graphicx} % graficos
\usepackage{fancyhdr}
\usepackage[margin=2.5cm, top=2.5cm,includefoot]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[table,xcdraw]{xcolor}
\usepackage{minted}

% VARIABLES 
\newcommand{\logoITB}{./data/img/ITB_Logo_417.png}
\newcommand{\autor}{Marc Hortelano }
\newcommand{\startDate}{Abril 2021}

\newcommand{\LogoGPTS}{./data/img/Logo_ptls.png}

\newcommand{\cronologia}{./data/img/Cronograma vertical.png}
\newcommand{\scriptEstruc}{./data/img/Estructura_Script.png}

% ADICIONALES
%\renewcommand{\contentsname}{Index}
\setlength{\headheight}{50.2pt}
\pagestyle{fancy}
\fancyhf{}
\lhead{\includegraphics[width=4cm]{\logoITB}}
\rhead{\includegraphics[width=2cm]{\LogoGPTS}}
\rfoot{\thepage}
\lfoot{\autor}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\headrule}{\hbox to\headwidth{\color{blue}\leaders\hrule height \headrulewidth\hfill}}
\setlength\parindent{0pt}


% DOCUMENT START
\begin{document}

\begin{titlepage}

    \begin{center}
        \begin{figure}[htb]
            \begin{center}
                \includegraphics[width=4.5cm]{\LogoGPTS}
                \includegraphics[width=6cm]{\logoITB}
            \end{center}
                \vspace*{0.1in}
        \end{figure}

        \vspace*{0.2in}
        \begin{Large}
            \textbf{GPenT0ols} \\
        \end{Large}
        \vspace*{0.3in}
        \begin{large}
            Aquest projecte esta creat per en \autor en el curs de Grau Superior\\
            \vspace*{0.3in}
            \startDate \\
        \end{large}
        \vspace*{0.3in}
        \rule{80mm}{0.1mm}\\
        \vspace*{0.1in}
        \begin{large}
        Tutor: Victor Marquina\\
        - \\
        \end{large}
            Grau Superior - Administraci√≥ de Sistemes Inform√†tics en Xarxa\\
        \vspace*{0.15in}
            especialitat en Ciberseguretat \\
        \vspace*{0.6in}
    \end{center}

    \end{titlepage}
    % ---- %
    \clearpage
    \tableofcontents
    \clearpage
    % ----- %
    \setcounter{page}{2}
    \section{Abstract}
When you start a project you look for precision, but I think the most important thing for me is how you do it.
It's how you do it. My main goal is to enjoy learning about this subject as much as possible.
The topic I have chosen has been very complicated to define because it can be very broad and sometimes you can get saturated with so much information you find on the Internet.
First of all I am going to write about my motivations. Why I have chosen this final project and not another one, since I have had in mind several alternatives and all of them very similar.

Then I would like to show how I have done the project, the steps I have followed and show the final result. Add that my goal of this project is that other people can use it as they want. Which I will show how I have planned it so that it has no security problems as well as how to use it.

As I said before I hope to enjoy and assimilate as much as I can doing this kind of work because I think it helps me a lot to get out of my comfort zone and this kind of challenges makes learning much more fun.

\pagebreak
    \section{Introducci√≥}
   
    Feia temps que volia crear-me una eina automatitzada per poder realitzar pentestings, a m√©s a m√©s treballar una mica el desenvolupament web i con√®ixer noves tecnologies tamb√© estava dins el meu pla.
La idea del projecte es realitzar un entorn de pentesting de forma gr√†fica mitjan√ßant una web. Aquest entorn √©s una infraestructura en Docker on recollir√© totes les eines que son √∫tils per a mi. Em permetr√† realitzar una auditoria de pentesting i desplegar-la de forma c√≤mode i r√†pida.\par
Un pentest consisteix en realitar un proc√©s d'avaluaci√≥ coordinat. La prova implica una varietat d'elements, per√≤ per a simplificar l'explicaci√≥, un individu o equip contractat accedeix al sistema, avaluaria tot el sistema cercant vulnerabilitats o febleses a trav√©s d'una metodologia predefinida, aquestes vulnerabilitats s√≥n explotades de manera controlada i permet identificar el risc per a l'organitzaci√≥. \par\par 
La idea s'origina en la necessitat d'automatitzar i les ganes d'aprendre o millorar un llenguatge de programaci√≥, concretament Python. Com he comentat anteriorment aquest projecte no ha set la primera idea que he tingut, ja que abans han passat varies molt similars i molt interessants. Una d'aquestes i que m'ha ajudat molt a obtenir aquesta idea final, era crear un plugin del Framework caldera.
Caldera √©s un framework que utilitza les t√†ctiques de MITRE ATT\&CK, i s'utilitza tant per red team com per blue. Aquest inici em va permetre entendre una mica el funcionament de com estava programat.
Per√≤ aquesta idea no m'acabava de convecer, ja que principalment volia crear una eina per realitzar pentesting i no de red team. Molta gent ho engloba tot i realment s√≥n metodologies diferents. M√©s endavant explicar√© que signifiquen aquests conceptes, per√≤ detallar aquesta part ho he trobat important perqu√® ha set de gran ajuda per obtenir la idea final.
Finalment vaig decidir crear la meva pr√≤pia eina des de zero, anomenada GPenTools. Com he dit, ho escriure principalment amb Python tant l'entorn gr√†fic com la majoria de scripts. El que far√© ser√† una web on hi hagui una shell interactiva i tindr√© totes les eines de pentesting que consideri. Aquesta web et permetr√† modificar r√†pidament el script i tamb√© crear tasques automatitzades.
Per la creaci√≥ d'aquesta eina m'ha servit d'inspiraci√≥ altres eines com \href{https://github.com/byt3bl33d3r/CrackMapExec}{\color{blue}crackmapexec} i \href{https://github.com/Tib3rius/AutoRecon}{\color{blue}autorecon}.\par
Tota la informaci√≥ la compartir√© en el meu repositori de Github, ja que ho vull fer de forma p√∫blica i que qualsevol persona la pugui utilitzar. \\

    \begin{center}
        Enlla√ß del repositori: \href{https://github.com/Th3FirstAvenger/GPenT0ols}{\color{blue}https://github.com/Th3FirstAvenger/GPenT0ols}\\
    \end{center}
\pagebreak
    \section{Objectius}
    Per poder executar aquest projecte, ha set necessari complir uns requisits m√≠nims. Aquest requisit seria comptar amb les bases de Linux i tenir uns coneixements de pentesting. Els objectius que m'agradaria assolir serien aconseguir una primera experi√®ncia desenvolupant una eina automatitzada totalment pr√≤pia amb el llenguatge de programaci√≥ de python, poder aprofitar aquesta eina per implementar-la en les auditories i seguir treballant amb ella per aconseguir millores.
Per complir els objectius ha set necessari una primera fase de planificaci√≥, aquesta part consider-ho que ha set la m√©s important ja que soc una persona que li agrada realitzar inversions a llarg termini i tenir una bona preparaci√≥.

Com b√© deia Abraham Lincoln " Give me six hours to chop down a tree and I will spend the first four sharpening the ax. " Dona'm sis hores per tallar un arbre i em passar√© les quatre primeres afilant la destral.

Al tenir poca experi√®ncia en desenvolupar un projecte de programaci√≥ a llarg termini, com es normal he com√®s alguns errors i imprevistos. Sent veritat, que gr√†cies a l'haver planificat una idea inicial i ben estructurada he rectificat a temps sense que hagi complicat molt el projecte. Quan dic que no tinc experi√®ncia vull fer refer√®ncia que jo en l'√†mbit de programaci√≥, nom√©s he realitzat scripts automatitzats i creaci√≥ d'algun exploit web. Aquests a nivell b√†sic.
\pagebreak
    \section{An√†lisi de la programaci√≥}
    La planificaci√≥ del projecte ha estat estructurada de la seg√ºent forma: 
    \begin{figure}[h]
        \centering
          \includegraphics[scale=0.4]{\cronologia}
            Figura 1: Cronograma
    \end{figure}
    \pagebreak
    \section{Resultats}
    En aquest apartat compartir√© el codi i les instruccions per poder utilitzar la eina GPenT0ols. Tota la informaci√≥ es troba en el meu repositori de github que he anunciat anteriorment. 

    Per realitzar la instal¬∑laci√≥ recomano que es faci amb docker ja que et permet tenir la ultima versi√≥ del projecte amb totes les eines i llibreries necessaries. Apart aquesta eina unicament ocupa 3 GB en la que cada vegada que es utilitzada s'elimina automaticament a no se que utilitzis configuracions que no s'indiquen a la instal¬∑laci√≥. 

\subsection{Instal¬∑laci√≥}
Primer de tot es necessari tenir-ho descarregat

\begin{minted}
[
frame=lines,
framesep=2mm,
bgcolor=white,
fontsize=\footnotesize,
]
{bash}
git clone https://github.com/Th3FirstAvenger/GPenT0ols.git /opt/GPenT0ols
cd /opt/GPenT0ols
\end{minted}

\subsubsection{Per utilitzar python3}
En aquest cas ja tindriem l'eina descarregada. Faltaria descarregar i instal¬∑lar les depend√®ncies minimes per poder utilitzar l'eina. Per tenir-ho es pot fer us de la seg√ºent comanda: \par 
\textit{* Aquesta comanda es valida per kali linux, en altres distribucions es probable que hagis de realitzar una instal¬∑laci√≥ manual. }


\begin{minted}
[
frame=lines,
framesep=2mm,
bgcolor=white,
fontsize=\footnotesize,
]
{bash}
apt-get update && \
        apt-get install -y \
    python3 \
    python3-pip \
    git \
    nmap \
    masscan \
    smbmap \
    whatweb \
    snmp \
    wget \
    nbtscan \
    wpscan \
    enum4linux \ 
    nikto \
    ffuf \
    golang \
    python3-venv \
    crackmapexec \
    seclists 
\end{minted}

El seg√ºent pas ja es realitzar l'execuci√≥. 


\begin{minted}
[
frame=lines,
framesep=2mm,
bgcolor=white,
fontsize=\footnotesize,
]
{bash}
python3 AutoGPenT0ols.py -h 
\end{minted}

    \subsubsection{Docker (Recomenada)}
    A continuaci√≥ mostrar√© els passos per instal¬∑lar l'eina amb docker.
Per la creaci√≥ de la imatge haurem d'executar la seg√ºent comanda.
\begin{minted}
[
frame=lines,
framesep=2mm,
bgcolor=white,
fontsize=\footnotesize,
]
{bash}
docker build -t capitanj4ck/gpent0ols .
\end{minted}
Per fer l'execuci√≥ es bestant facil i com he indicat abans d'aquesta forma l'eina no es guarda i s'elimina cuan acaba l'execuci√≥. Per iniciar utilitzariem la seg√ºent comanda:
\begin{minted}
[
frame=lines,
framesep=2mm,
bgcolor=white,
fontsize=\footnotesize,
]
{bash}
docker run --rm -it -v /tmp/gpt_report:/tmp/gpt_report capitanj4ck/gpent0ols -h
\end{minted}

Recomano afegir el seg√ºent alies per fer l'execuci√≥ d'una forma m√©s r√†pida: 

\begin{minted}
[
frame=lines,
framesep=2mm,
bgcolor=white,
fontsize=\footnotesize,
]
{bash}
alias gpt="docker run --rm -it -v /tmp/gpt_report:/tmp/gpt_report capitanj4ck/gpent0ols"
\end{minted}

\pagebreak
\subsection{Funcionament}
Primer de tot explicar√© com esta estrucurada l'eina. M'agradaria donar molta m√©s √©nfasi a l'apartat del codi ja que la web encara enst√† en desenvolupament. He prioritzat aprendre el funcionament de python abans que flask, l'objectiu inicial era tenir una eina propia.\par 
A l'executar l'eina ens permet realitzar diferents funcions. Com he dit anteriorment, el que ens permet realitzar aquesta eina es enumerar qualsevol equip de forma b√†sica. 
Com que la meva intenci√≥ es seguir treballant amb aquesta eina, inicialment vaig planificar una estructura que em permet√©s poder desenvolupar el projecte a llarga durada i no fos √∫nicament un fitxer python que ho realitzes tot. Un dels objectius era entendre com desenvolupar una eina de forma professional i no √∫nicament teclejar i entendre el codi. Per aquest motiu vaig estar preguntat a professionals i veien diferents programes realitzats en python. D'aquesta forma em van servir d'inspiraci√≥ diferents programes i amb aquesta ajuda vaig aconseguir planificar una estructura que fins el dia d'avui no he tingut molt problemes.

Per tant procedir√© en mostrar com la tinc estructurada.    
\begin{figure}[h]
          \includegraphics[scale=0.5]{\scriptEstruc}
        \centering\par
            Figura 2: Estructura de l'eina
    \end{figure}

    \subsubsection{Codi}
Veiem que inicialment tenim un fitxer main, aquest em permet cridar les diferents llibreries creades i cada llibreria t√© les llibreries necess√†ries i aix√≠ no omplo el primer fitxer de codi que √∫nicament em pot servir per a un servei.
El contingut d'aquest fitxer seria el seg√ºent:

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=white,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3 
## 
                           #                                                                                                                                                                                         
                           ##                                ###                                                                                                                                                     
  ###### #######  ######## ###  ## ######## ####### #######  ###         ####                                                                                                                                        
 ###           ##          #### ##    ###   ##   ##       ## ###        ###                                                                                                                                          
 ###  ##  ######   ####### #######    ###   ##   ##  ##   ## ###        ###                                                                                                                                          
 ###  ##  ###      ###     ### ###    ###   ##   ##  ##   ## ###        ###                                                                                                                                          
  ######  ###      ####### ###  ##    ###   #######   #####  ####### #####                                                                                                                                           
                                 #                                                                                                                                                                                   
# Author : CapitanJ4ck
##

import signal
from sys import exit
import os
import time
import subprocess
from pwn import *
from gptools_cli import gen_cli_args
from services.recon import recon
from services.web import web
from services.smb import smb
from services.ldap import ldap
from services.ftp import ftp

## Detect Contrl + C 
def signal_handler(key, frame):
    # Handle any cleanup here
    exit = log.progress("SIGINT or CTRL-C detected.")
    exit.status("Exiting...")
    time.sleep(1)
    exit.failure("Exiting gracefully")
    sys.exit(1)

signal = signal.signal(signal.SIGINT, signal_handler)


# Vars 

# Make directories

def mdir(dir_name):
    
    directory_created = True

    try:
        os.makedirs(dir_name)
    
    except OSError:
        directory_created = False
    
    return directory_created

# Managment function, we can build directories for save outputs

def build_infraestucture(dir_name,output):

    infra = log.progress("Managment")
    
    infra.status("Building structure on ")

    
    if not os.path.exists(dir_name):
        directory_created = mdir(dir_name)
        if directory_created: 
            infra.success("Succesfully created the directory {}".format(dir_name))
        else: 
            infra.failure("Creation of the directory {} failed".format(dir_name))
    else: 
        infra.success("Directory {} already exist".format(dir_name))

def run(dir_file, command,service,debug):
    out = dir_file + "out.txt"
    err = dir_file + "err.txt"
#    parsed_command = command ## Util working other commands 
    parsed_command = []
    
    for c in command:
        parsed_command.append(c.replace('¬∑',' '))
    

    p = log.progress(service)
    
    with open(out,'w+') as fout:
        with open(err,'w+') as ferr:
            
            p.status("Running")           
            try: 
                out=subprocess.call(parsed_command,stdout=fout,stderr=ferr)
                # reset file to read from it
                fout.seek(0)
                # save output (if any) in variable
                output=fout.read()
                if debug:
                    print(output) 

                # reset file to read from it
                ferr.seek(0) 
                # save errors (if any) in variable
                errors = ferr.read()
                if out != 0: 
                    p.failure("Something wrong")
                else: 
                    p.success("Succesfully!")
            except: 
                p.failure("Command timeout")
            
def main():
    
    # Get args from Namespace type 
    args = vars(gen_cli_args())
    
    # Get service
    service = args['services']
    target = args['target'] 
    debug = args['verbose'] 
    out_path = os.path.join(args['path'],(os.path.join(args['target'],service)))
    config_path = os.path.join(os.getcwd(), os.path.join("data",service))
    
    web_path = out_path # CHANGE WHEN WEB WORKS

    # Build infraestucture for save output
    build_infraestucture(out_path,config_path)

    #print(args) # debug
    # Start progress
    service_progress = log.progress(service)
    
    ## Recon scanner
    if 'recon' == service: 
        scanner = recon(args,config_path,out_path)
    ## Web scanner
    elif 'web' == service: 
        scanner = web(args,config_path,out_path)
    ## smb scanner
    elif 'smb' == service: 
        scanner = smb(args,config_path,out_path) 
    ## ldap scanner
    elif 'ldap' == service: 
        scanner = ldap(args,config_path,out_path) 
    ## ftp scanner
    elif 'ftp' == service: 
        scanner = ftp(args,config_path,out_path) 
    
    print("-- ùíûùíΩùëíùí∏ùìÄ ùí¢ùí´ùëíùìÉùíØùí™ùëúùìÅùìà --")
    for description, command in scanner.items():
        service_progress.status("{}".format(command))
        if args['show_commands']:
            print(command)
            time.sleep(2) # Check without exec 
        else: 
            run(web_path,command.split(),description,debug)

if __name__ == '__main__':
    main()
\end{minted}

En aquest fitxer mostrat anteriorment el que fa es agafar els arguments passats pel fitxer gpentools\_cli.py. A partir del que passa l'usuari executar√† una cosa o altra. M√©s endavant mostrar√© el que mostra i el seu funcionament.\par

_NOM FITXER

Aquest fitxer fa √∫s del m√≤dul argparse, aquest m√≤dul em permet agafar els arguments de forma f√†cil i compatible de moltes formes. Tamb√© he escollit aquest m√≤dul perqu√® em permet crear com submen√∫s i aprofundir m√©s en detall cada servei. Aquest m√≤dul el comparteixo a la webgrafia, ja que ha set complexa entendre el seu funcionament per√≤ finalment he aconseguit implementar-ho.
\par

El contingut del fitxer gpentools\_cli √©s el seg√ºent: 

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=white,
fontsize=\footnotesize,
linenos
]
{python}
import argparse
import sys
from argparse import RawTextHelpFormatter
from lib.core.__version__ import __version__
from helpers.logger import highlight

def gen_cli_args():

    VERSION  = __version__
    CODENAME = 'CapitanJ4ck'


    parser = argparse.ArgumentParser(description="""
                           #                                                 
                           ##                                ###             
  ###### #######  ######## ###  ## ######## ####### #######  ###         ####
 ###           ##          #### ##    ###   ##   ##       ## ###        ###  
 ###  ##  ######   ####### #######    ###   ##   ##  ##   ## ###        ###  
 ###  ##  ###      ###     ### ###    ###   ##   ##  ##   ## ###        ###  
  ######  ###      ####### ###  ##    ###   #######   #####  ####### #####   
                                 #                                           
                                 {}: {}
                                 {}: {}
""".format(highlight('Version', 'red'),
           highlight(VERSION),
           highlight('Codename', 'red'),
           highlight(CODENAME)),

                                    formatter_class=RawTextHelpFormatter,
                                    epilog="We are in... Let the hacking begin!")

    parser.add_argument("-t", type=int, dest="threads", default=100, help="set how many concurrent threads to use (default: 100)")
    parser.add_argument("--verbose", action='store_true', help="enable verbose output")
    parser.add_argument("--show-commands", action='store_true', help="Just show commands")
    parser.add_argument("--path",dest="path", default='/tmp/gpt_report/', help="Destination path (default: /tmp/gpt_report)")

    std_parser = argparse.ArgumentParser(add_help=False)
    std_parser.add_argument("target", nargs='?', type=str, help="(Target Required *) The target IP(s), range(s), CIDR(s), hostname(s), FQDN(s), file(s) containing a list of targets ")
    scan_parser = argparse.ArgumentParser(add_help=False)
    scan_parser.add_argument(
            '--scanner',
            help='Select scanner (default : full_scanner)',
            nargs='?',
            default = 'full_scanner'
            )

    have_info_parser = argparse.ArgumentParser(add_help=False)
    have_info_parser.add_argument(
            '--tags',
            help='What do you have? [Creds, NoCreds, Hash, Shell] (Default: NoCreds)',
            default = 'NoCreds',
            nargs='?'
            )

    wlist_parser = argparse.ArgumentParser(add_help=False)
    wlist_parser.add_argument("-w", metavar="WORDLIST", dest='wordlist', nargs='+', help="set wordlist  (Default SecList wordlist)")
    
    ssl_parser = argparse.ArgumentParser(add_help=False)
    ssl_parser.add_argument(
            '--ssl',
            help='usage of SSL/TLS requests',
            action='store_true'
            )

    cred_parser = argparse.ArgumentParser(add_help=False)
    cred_parser.add_argument("-u", metavar="USERNAME", dest='username', nargs='?', default=[], help="username(s) or file(s) containing usernames")
    cred_parser.add_argument("-p", metavar="PASSWORD", dest='password', nargs='?', default=[], help="password(s) or file(s) containing passwords")
    cred_parser.add_argument("-H", metavar="HASH", dest='HASH', nargs='?', default=[], help="Pass The hash")

    subparsers = parser.add_subparsers(title='services', dest='services', description='available options')


    # Arguments Recon

    recon = subparsers.add_parser('recon', help='Initial recon', parents=[std_parser,scan_parser]) ## Get new arguments and can introduce std_parser arguments
    recon.add_argument(
            '--all-ports',
            help='scan all ports',
            action='store_true'
            )
    
    recon.add_argument(
            '--ports',
            help='scan specific ports',
            nargs='?'
            )
    
    recon.add_argument(
            '--full',
            help='Full recon scan',
            action='store_true'
            )


    # Arguments WEB

    web = subparsers.add_parser('web', help='Web server scanner', parents = [cred_parser, std_parser,wlist_parser,scan_parser,ssl_parser])
    
    web.add_argument(
            '--port',
            help='scan specific port (Default 80)',
            nargs='?',
            default = '80'
            )
    
    web.add_argument(
            '--file-path',
            help='Specify to find the requested resource and start the enumeration with that route (Default / )',
            nargs='?',
            default = '/'
            )
    

    web.add_argument(
            '--cms',
            help='What do you have? [Wordpress, Joombla, Drupal] (Default: NoCreds)',
            default = 'NoCreds',
            nargs='?'
            )
    # Arguments SMTP

    smtp = subparsers.add_parser('smtp', help='smtp enumeration')

    # Arguments SMB

    smb = subparsers.add_parser('smb', help='Enum smb', parents = [cred_parser,std_parser,have_info_parser])

    smb.add_argument(
            '--port',
            help='scan specific port (Default 445)',
            nargs='?',
            default = '445'
            )
    
    
    # Arguments FTP
    
    ftp = subparsers.add_parser('ftp', help='FTP enum', parents = [cred_parser,std_parser,have_info_parser,ssl_parser])

    ftp.add_argument(
            '--port',
            help='scan specific port (Default 22)',
            nargs='?',
            default = '22'
            )
    
    
    # Argumets LDAP

    ldap = subparsers.add_parser('ldap', help='LDAP enum', parents = [cred_parser,std_parser,have_info_parser])
    
    ldap.add_argument(
            '--port',
            help='scan specific port (Default 389)',
            nargs='?',
            default = '389'
            )

    # Arguments SNMP
    
    snmp = subparsers.add_parser('snmp', help='Enum SNMP', parents = [cred_parser,std_parser])

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()
    
    check = vars(args)


    if not check['target']:
        if check['services'] == 'recon':
            recon.print_help()
        elif check['services'] == 'web':
            web.print_help()
        elif check['services'] == 'smb':
            smb.print_help()
        elif check['services'] == 'smtp':
            smtp.print_help()
        elif check['services'] == 'ftp':
            ftp.print_help()
        elif check['services'] == 'ldap':
            ldap.print_help()
        elif check['services'] == 'snmp':
            snmp.print_help()
        else: 
            parser.print_help()
        sys.exit(1)

    return args
\end{minted}

Una vegada s'han passat els arguments de forma correcta ja passen a executar els serveis. Cada servei t√© el seu fitxer i est√† creat com una llibreria. En el fitxer Main, veiem que crida unes funcions i aquestes funcions s√≥n les que es troben dins de cada servei. S√≠ que la metodologia √©s molt similar a cada fitxer per√≤ a poc a poc anir√© implementant millores. Per exemple els fitxers recon i web s√≥n molt similars en canvi amb samba i ldap ja s√≥n diferents. El motiu es que he estat realitzant proves per veure quina seria la m√©s efica√ß i de moment crec que l'estructura que mantindr√© es la forma que estan configurats la segona opci√≥.
En primer lloc la primera opci√≥, fa √∫s dels fitxers de configuraci√≥ .yaml per√≤ l'estructura es diferent. Podem observar que la primera opci√≥ s'ha de passar un argument i ser√† el mateix que cridar√† en el fitxer yaml, en canvi la segona opci√≥ utilitzem sempre els mateixos tags i busca a trav√©s d'aquest tags. Si que pel servei de recon la millor opci√≥ es l'actual pero per l'apartat web seria modificar-ho i utilitzar els tags, per√≤ aquesta part la fa molt m√©s complexa, ja que s'hauria de planificar quins serien aquest tags i com ho organitzaria per aquest motiu de moment ho mantinc com est√†.
\par

La metodologia que hauriem de seguir es realiar en primer lloc un recon, aquesta funci√≥ ens permet enumerar a nivell de xarxa tots els ports que poden esta oberts. 

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=white,
fontsize=\footnotesize,
linenos
]
{python}

\end{minted}
\subsection{Utilitzaci√≥}
    \section{Conclusions}

    \section{Referecies bibliografiques}



\end{document}


